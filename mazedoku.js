'use strict';

// Maximum number of attempts to generate a solvable puzzle.
//
// This prevents the browser from freezing if a suitable puzzle cannot be
// generated quickly enough, which tends to happen when generating very
// large puzzles.
const GENERATE_PUZZLE_ATTEMPTS = 100000;

// This is the top-level puzzle creation function.
//
// The high-level algorithm is pretty simple:
//
//  1. Generate a solvable candidate puzzle (i.e. a maze).
//  2. Generate a random solution for the puzzle (i.e. digits to fill the grid).
//  3. Generate the initial clues as a subset of the solution digits.
//
// Then recreate the SVG drawing to let the user play with it!
function updatePuzzle(H, W) {
    let puzzle = generateSolvableMaze(H, W, GENERATE_PUZZLE_ATTEMPTS);
    if (puzzle == null) {
        alert("Failed to generate a puzzle after " + GENERATE_PUZZLE_ATTEMPTS + " attempts!");
        return false;
    }

    const {candidates, neighbours} = puzzle;
    const solution = generateRandomSolution(candidates, neighbours);
    const clues = generateRandomClues(candidates, neighbours, solution);
    updatePuzzleSvg(H, W, {...puzzle, clues});
    return true;
}

// Generates a solvable puzzle of height H and width W.
//
// The output of this function is the same as generateCandidateMaze(), i.e.
// it describes a maze only, no digits have been decided yet.
//
// This repeatedly calls generateCandidateMaze() followed by countSolutions()
// to check if the maze is actually solvable. Some mazes are unsolvable because
// they are overconstrained: it's not possible to place a digit in every cell
// without violating the constraint that two neighbouring cells may not contain
// the same digit.
//
// Example of an unsolvable candidate puzzle that might be generated:
//
//  +--+--+--+
//  | a  b  c|
//  +--+--+  +
//  | d  e  f|
//  +  +--+  +
//  | g| h  i|
//  +--+--+--+
//
function generateSolvableMaze(H, W, maxAttempts) {
    for (let attempt = 0; attempt < maxAttempts; ++attempt) {
        const puzzle = generateCandidateMaze(H, W);
        if (countSolutions(puzzle.candidates, puzzle.neighbours, 1) > 0) return puzzle;
    }
    return null;
}

// generateCandidateMaze(H, W) generates a candidate maze of height H and
// width W.
//
// A maze is like a puzzle with walls but no digits. It might not even be solvable!
// See generateSolvableMaze() how this is used to generate a solvable maze.
//
// The algorithm used to generate the maze is a randomized version of Kruskal's
// algorithm to find a spanning tree in a graph. For details, see:
//
// https://en.wikipedia.org/wiki/Maze_generation_algorithm#Randomized_Kruskal's_algorithm
// 
// The walls generated by this function form a maze with a unique path between
// any pair of cells (i.e., the connected cells form a tree). It would also be
// possible to create puzzles with multiple paths ((i.e. cycles in the maze) or
// with disconnected subgraphs.
//
// In the result, cells are numbered in row-major order starting from 0, so that
// the cell at position (row, col) has index (row*W + col).
//
// This function returns an object with the following keys:
//
//  - candidates: an array of H*W integers. Each integer is a bitmask of
//      possible digits. For example, a cell on the intersection between a
//      corridor of length 3 and 4 can only contain digits 1, 2, 3, encoded as
//      bitmask 7.
//
//  - neighbours: an array of H*W arrays, where each array is a list of
//      neighbouring cell indices. Cells are considered neighbours if the same
//      digit cannot occur in both of them. That means that in the context of
//      this puzzle, the neighbours of a cell are those in the same horizontal
//      or vertical corridor or at a knight's move's distance.
//
//  - mazeEdges: an array of pairs of cells that are connected, where each edge
//      is a pair of cell indices.
//
//  - mazeWalls: an array of pairs of cells that are separated by a wall, encoded
//      the same way as mazeEdges. This is the complement of mazeEdges: each
//      possible pair of adjacent cells occurs either in mazeEdges or mazeWalls,
//      depending on whether there is a wall between the cells or not.
//
// The maze is fully defined by either `mazeEdges` or `mazeWalls`; both fields are
// kept to make it easy to generate the SVG later. `candidates` and `neighbours`
// are derived from the structure of the maze, and provided to make it easy to
// generate solutions.
//
// For example, the following result:
//
//  {
//      mazeEdges: [
//          [0,1],[2,5],[5,8],[3,4],[7,8],[4,7],[3,6],[0,3]],
//      mazeWalls: [
//          [4,5],[6,7],[1,2],[1,4]],
//      candidates: [
//          3,3,7,
//          3,3,7,
//          7,3,3],
//      neighbours: [
//          [5,7,1,3,6], [6,8,0],   [3,7,5,8],
//          [2,8,0,6,4], [3,7],     [0,6,2,8],
//          [1,5,0,3],   [0,2,4,8], [1,3,2,5,7]]
//  }
//
// Encodes the following maze (showing cell indices, but not candidate bitmasks).
// 
//  +--+--+--+
//  | 0  1| 2|
//  +  +--+  +
//  | 3  4| 5|
//  +  +--+  +
//  | 6  7  8|
//  +--+--+--+
//
function generateCandidateMaze(H, W) {
    const allEdges = [];
    const hasWall = {};
    for (let r = 0; r < H; ++r) {
        for (let c = 0; c < W; ++c) {
            if (r + 1 < H) allEdges.push([W*r + c, W*(r + 1) + c]);
            if (c + 1 < W) allEdges.push([W*r + c, W*r + (c + 1)]);
        }
    }
    const mazeEdges = [];
    const mazeWalls = [];
    shuffleInPlace(allEdges);
    const sets = new DisjointSets(H*W);
    for (const edge of allEdges) {
        const [v, w] = edge;
        if (!hasWall[v]) hasWall[v] = {};
        if (sets.merge(v, w)) {
            mazeEdges.push(edge);
            hasWall[v][w] = false;
        } else {
            mazeWalls.push(edge);
            hasWall[v][w] = true;
        }
    }

    const candidates = [];
    const neighbours = [];
    const maxMask = (1 << Math.max(H, W)) - 1;
    const knightsMoves = [[-2, -1], [-2, 1], [-1, -2], [-1, 2], [1, -2], [1, 2], [2, -1], [2, 1]];
    for (let r = 0; r < H; ++r) {
        for (let c = 0; c < W; ++c) {
            candidates.push(maxMask);
            neighbours.push([]);
            for (let [dr, dc] of knightsMoves) {
                let rr = r + dr;
                let cc = c + dc;
                if (rr >= 0 && rr < H && cc >= 0 && cc < W) {
                    neighbours[W*r + c].push(W*rr + cc);
                }
            }
        }
    }
    for (let r1 = 0; r1 < H; ++r1) {
        for (let c1 = 0; c1 < W; ++c1) {
            if (c1 == 0 || hasWall[W*r1 + (c1 - 1)][W*r1 + c1]) {
                // Horizontal corridoor
                let c2 = c1;
                while (c2 + 1 < W && !hasWall[W*r1 + c2][W*r1 + (c2 + 1)]) ++c2;
                if (c2 > c1) {
                    const mask = (1 << (c2 + 1 - c1)) - 1;
                    for (let c3 = c1; c3 <= c2; ++c3) {
                        candidates[W*r1 + c3] &= mask;
                        for (let c4 = c1; c4 <= c2; ++c4) {
                            if (c3 != c4) {
                                neighbours[W*r1 + c3].push(W*r1 + c4);
                            }
                        }
                    }
                }
            }
            if (r1 == 0 || hasWall[W*(r1 - 1) + c1][W*r1 + c1]) {
                // Vertical corridoor
                let r2 = r1;
                while (r2 + 1 < H && !hasWall[W*r2 + c1][W*(r2 + 1) + c1]) ++r2;
                if (r2 > r1) {
                    const mask = (1 << (r2 + 1 - r1)) - 1;
                    for (let r3 = r1; r3 <= r2; ++r3) {
                        candidates[W*r3 + c1] &= mask;
                        for (let r4 = r1; r4 <= r2; ++r4) {
                            if (r3 != r4) {
                                neighbours[W*r3 + c1].push(W*r4 + c1);
                            }
                        }
                    }
                }
            }
        }
    }

    return {
        mazeEdges,
        mazeWalls,
        candidates,
        neighbours,
    }
}

// This class implements a disjoint-set data structure.
//
// It is used to implement Kruskal's algorithm in generateCandidateMaze().
//
// Details: https://en.wikipedia.org/wiki/Disjoint-set_data_structure
class DisjointSets {
	// Creates a data structure with `size` distinct elements labeled
    // 0, 1, .., size - 1. Initially each element is its own set. 
    constructor(size) {
        this.roots = [];
        this.sizes = [];
        for (let i = 0; i < size; ++i) {
            this.roots.push(i);
            this.sizes.push(i);
        }
    }

    // If vertices i and j are members of disjoint sets, this method merges the
    // two sets and returns true. Otherwise, the elements already belong to the
    // same set, and false is returned instead.
    merge(i, j) {
        // Returns the representative element for item `i`, and, as a side effect,
        // compress the path to the root to improve performance of future lookups.
        const findRoot = (i) => {
            return this.roots[i] == i ? i : this.roots[i] = findRoot(this.roots[i]);
        }
        i = findRoot(i);
        j = findRoot(j);
        if (i == j) return false;
        if (this.sizes[i] > this.sizes[j]) {
            this.roots[j] = i;
        } else {
            this.roots[i] = j;
        }
        return true;
    }
}

// Randomly shuffles the elements of an array.
//
// This function shuffles in-place, i.e., it does not return anything, but
// reorders the elements of the array argument.
//
// Algorithm used is the Fisher-Yates shuffle:
// https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle
function shuffleInPlace(array) {
    const n = array.length;
    for (let i = 0; i < n; ++i) {
        let j = i + Math.floor(Math.random() * (n - i));
        let temp = array[i];
        array[i] = array[j];
        array[j] = temp;
    }
}

// Returns a randomly chosen element from an array.
// Throws if the array is empty.
function getRandomElement(a) {
    if (a.length === 0) throw "a is empty";
    return a[Math.floor(Math.random() * a.length)];
}

// Given an integer, returns the indices of the bits that are set.
//
// e.g. getBits(0) -> [], getBits(34) -> [1, 5] 
function getBits(bitMask) {
    const bits = [];
    for (let i = 0; (1 << i) <= bitMask; ++i) {
        if ((bitMask & (1 << i)) !== 0) bits.push(i);
    }
    return bits;
}

// Given an integer, returns the index of the first bit set.
//
// Throws if the argument is zero.
//
// e.g. getFirstBit(33) -> 0, getFirstBit(34) -> 1.
function getFirstBit(bitMask) {
    if (bitMask === 0) throw "zero bitmask";
    let i = 0;
    while ((bitMask & (1 << i)) === 0) ++i;
    return i;
}

// Given an integer that is a power of two, returns the index of the only bit set.
// (This is equivalent to the base 2 logarithm of the number.)
//
// Similar to getFirstBit(), except this throws an error if the argument has
// more than 1 bit set.
function getOnlyBit(bitMask) {
    if (bitMask === 0) throw "bitmask is 0";
    let i = getFirstBit(bitMask);
    if (bitMask != (1 << i)) throw "bitmask has more than 1 bit set";
    return i;
}

// This function takes a valid puzzle and a complte solution, and returns a list
// of clues that is a subset of the solution.
//
// `candidates` and `neighbours` are formatted as returned by
// generateCandidateMaze().
//
// `solution` is an array of H*W solution digits, as returned by
// generateRandomSolution().
//
// The result is in the same format as `solution`, except that some digits are
// replaced with 0 to indicate the corresponding cell is initially empty.
//
// The algorithm used is simple: we start with clues equal to the solution
// (i.e. all digits are initially given, which would not be much fun to solve!),
// then go through the clues one by one, and check if removing this clue would
// make the solution ambiguous (using countSolutions() > 1). If so, we keep the
// clue; if not, we remove it.
//
// Since this is a greedy algorithm, it doesn't necessarily return a minimal set
// of clues. However, the number of clues seems reasonably small in practice.
//
// To improve randomness, we go through the elements of `clues` in a random
// order (if we started from the top left, we'd end up with most clues
// concentrated in the bottom right of the grid, which is not nice). 
function generateRandomClues(candidates, neighbours, solution) {
    let indices = solution.map((_, i) => i);
    let clues = solution.map(() => 0);
    shuffleInPlace(indices);
    let fixedCandidates = solution.map(i => 1 << (i - 1));
    for (let i of indices) {
        let old = fixedCandidates[i];
        fixedCandidates[i] = candidates[i];
        if (countSolutions(fixedCandidates, neighbours, 2) > 1) {
            fixedCandidates[i] = old;
            clues[i] = solution[i];
        }
    }
    return clues;
}

// The solve() function takes a complete puzzle and enumerates all solutions.
//
// The solver is essential for puzzle generation, since it powers both
// countSolutions() and generateRandomSolution().
//
// The algorithm is a backtracking search, similar to what is used in Sudoku
// solvers (in fact, solve() can also solve Sudokus, if passed the appropriate
// values for candidates and neighbours.)
//
// On a high level, the solver alternates between two subroutines:
//
//  1. fixRecursively() finds cells with only a single candidate remaining, and
//     "fixes" them by marking the cell as fixed and then removing the fixed
//     digit from the candidate bitmasks of neighbouring cells. This may cause
//     some of those neighbours to get fixed in turn, which is why the function
//     that implements this functionality is called fixRecursively(), even
//     though the implementation is iterative.
//
//     If a cell is discovered without any remaining candidates,
//     fixRecursively() returns false to indicate that the puzzle is unsolvable.
//
//  2. search() finds cells with multiple candidates remaining, and chooses one
//     of the candidates to fill in, effectively "guessing" a digit, and trying
//     to see if it leads to a solution. Since the solution may be wrong (and
//     because solve() should enumerate all solutions if there are multiple),
//     it creates a copy of the puzzle first, so it can backtrack and try a
//     different guess later.
//
//     cellSelectionFunction and candidateSelectionFunction determine which cell
//     to fill in next, and the order in which to try the possible digits in
//     that cell, respectively.
//
//     If there are no unfixed cells remaining, that means the puzzle is solved,
//     and solutionFunction is invoked to handle the solution, and abort the
//     search if desired.
//
// Arguments are as follows:
//
//  - candidates is a list of N * M bitmasks; for cells that should be fixed
//    from the start (i.e. they contain a digit clue) the bitmask contains a
//    single bit.
//
//  - neighbours is a list of neighbour lists, as returned by
//    generateCandidateMaze().
//
//  - cellSelectionFunction is used to select the next cell to explore. It takes
//    a list of unsolved cell indices as an argument and returns a single index.
//    Possible implementions are selectMostConstrainedCell() and
//    getRandomElement().
//
//    As mentioned above, solve() always fixes cells with a single candidate
//    first, and only calls cellSelectionFunction when the remaining unfixed
//    cells have multiple candidates.
//
//  - candidateSelectionFunction determines the order in which the candidates
//    for the selected cell will be tried. It takes a bitmask as an argument and
//    returns a list of bit indices. Possible implementations are
//    selectRandomCandidates() or getBits(). Again, this function is only
//    invoked if there are multiple candidates to chose from.
//
//  - solutionFunction is a callback function that is invoked once for every
//    solution that is found. It takes an array of digits as its only argument.
//    If solutionFunction() returns a value that is truthy, then the search will
//    be aborted.
//
// solve() returns the first truthy value returned by solutionFunction(), or
// null if solutionFunction() always returns a falsy value, including if no
// solution is ever found.
function solve(candidates, neighbours, cellSelectionFunction, candidateSelectionFunction, solutionFunction) {
    function fixRecursively(candidates, fixed, todo) {
        for (const i of todo) {
            const bit = candidates[i];
            if (bit === 0 || (bit & (bit - 1) !== 0)) throw "invalid bit";
            if (fixed[i]) throw "already fixed";
            fixed[i] = true;
            for (let j of neighbours[i]) {
                let c = candidates[j];
                if ((c & bit) === 0) continue;
                c &= ~bit;
                if (c === 0) return false;
                candidates[j] = c;
                if ((c & (c - 1)) === 0) todo.push(j);
            }
        }
        return true;
    }

    function search(candidates, fixed) {
        let unfixedIndices = [];
        for (let i = 0; i < candidates.length; ++i) {
            if (!fixed[i]) unfixedIndices.push(i);
        }
        if (unfixedIndices.length === 0) {
            return solutionFunction(candidates.map(c => getOnlyBit(c) + 1));  // solution found!
        }
        const i = cellSelectionFunction(unfixedIndices, candidates);
        for (const c of candidateSelectionFunction(candidates[i])) {
            const bit = 1 << c;
            if ((candidates[i] & bit) === 0) throw "invalid candidate selected";
            const newCandidates = Array.from(candidates);
            const newFixed = Array.from(fixed);
            newCandidates[i] = bit;
            if (fixRecursively(newCandidates, newFixed, [i])) {
                let res = search(newCandidates, newFixed);
                if (res) return res;
            }
        }
        return null;
    }

    // Recursively fix all single-candidate cells before we start searching.
    let newCandidates = Array.from(candidates);
    let newFixed = Array.from(candidates, () => false);
    let todo = [];
    for (let i = 0; i < newCandidates.length; ++i) {
        let c = newCandidates[i];
        if (c === 0) return null;
        if ((c & (c - 1)) === 0) todo.push(i);
    }
    if (!fixRecursively(newCandidates, newFixed, todo)) return null;
    return search(newCandidates, newFixed);
}

// Counts the number of distinct solutions to a puzzle.
//
// Since the total number of solutions may be very large, and enumerating all of
// them can take a long time, this function accepts a `maxSolutions` parameter
// which causes the function to stop searching as soon as the maximum count has
// been reached.
// 
// For example, to check if a puzzle is solvable, we can pass maxSolutions = 1
// (a result of 1 means solvable). To check if the solution is unique, we can
// pass maxSolutions = 2 (a result of 2 means two or more solutions exist).
//
// Uses the selectMostConstrainedCell() heuristic to help narrow down the
// solution quickly, and getBits() because it's faster than
// selectRandomCandidates().
function countSolutions(candidates, neighbours, maxSolutions) {
    if (maxSolutions == undefined) maxSolutions = Infinity;
    let solutions = 0;
    solve(candidates, neighbours, selectMostConstrainedCell, getBits, () => ++solutions >= maxSolutions);
    return solutions;
}

// Generates a random solution for the given puzzle.
//
// The result is a list of H * W digits between 1 and 9 each, which satisfy
// the cell constraints imposed by `candidates` and `neighbours`.
//
// Uses getRandomElement() and selectRandomCandidates() as the cell and
// candidate selection functions to randomize the search as much as possible.
// This ensures that the generated solution is random, though probably not
// uniformly so (I'm not sure, I didn't think it all the way through).
//
// If there is no solution, this function returns null.
function generateRandomSolution(candidates, neighbours) {
    return solve(candidates, neighbours, getRandomElement, selectRandomCandidates, (solution) => solution);
}

// Cell selection function that returns the index of the cell with the fewest
// remaining candidates (or the first such index, if there is more than one
// possibility).
//
// `indices` is a list of cell indices that are not yet fixed.
// `candidates` is a list of candidate bitmasks per cell.
//
// The rationale for selecting the most constrained cell is that it keeps the
// branching factor low while we're high up in the recursion tree, which results
// in fewer total leaf nodes being created. This is just a heuristic, but one
// that works well in practice.
function selectMostConstrainedCell(indices, candidates) {
    let minBitCount = Infinity;
    let bestIndex = null;
    for (let i of indices) {
        let bits = candidates[i];
        let bitCount = 0;
        while (bits && bitCount < minBitCount) {
            bits &= bits - 1;
            ++bitCount;
        }
        if (bitCount < minBitCount) {
            minBitCount = bitCount;
            bestIndex = i;
        }
    }
    return bestIndex;
}

// Candidate selection function that returns the possible candidates in a random
// order. This is intended to improve the randomness of generated puzzles.
function selectRandomCandidates(candidateBitMask) {
    let candidates = getBits(candidateBitMask);
    shuffleInPlace(candidates);
    return candidates;
}

// This function recreates the SVG element that represents the puzzle.
// It's unreleated to the maze generation algorithm.
//
// Cells can be selected by clicking them. Digits can be entered by pressing
// number keys 1 through 9, and cleared with 0 or the delete key. Any digit
// conflicts are highlighted in red.
//
//  - H and W are the height and width of the maze.
//  - mazeWalls is a list of solid walls
//  - mazeEdges is a list of maze openings (i.e, absence of an edge)
//  - clues is a list of clue digits; 0 for none, or 1..9 for a clue
//  - candidates is a bitmask of candidate digits per cell
//  - neighbours is a list of neighbour cells per cell
//
// See generateCandidateMaze() for details how walls, edges, candidates and
// neighbours are encoded.
function updatePuzzleSvg(H, W, {mazeWalls, mazeEdges, clues, candidates, neighbours}) {
    const puzzleSvg = document.getElementById('puzzleSvg');
    while (puzzleSvg.lastChild) {
        puzzleSvg.removeChild(puzzleSvg.lastChild);
    }

    puzzleSvg.setAttribute('viewBox', '-0.5 -0.5 ' + (W + 1) + ' ' + (H + 1));

    function addLines(edges, className) {
        for (const [v, w] of edges) {
            const x1 = v % W;
            const y1 = (v - x1) / W;
            const x2 = w % W;
            const y2 = (w - x2) / W;

            const wallLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            wallLine.setAttribute('class', className);
            wallLine.setAttribute('x1', y1 == y2 ? x1 + 1 : x1);
            wallLine.setAttribute('y1', y1 == y2 ? y1     : y1 + 1);
            wallLine.setAttribute('x2', y1 == y2 ? x1 + 1 : x1 + 1);
            wallLine.setAttribute('y2', y1 == y2 ? y1 + 1 : y1 + 1);
            puzzleSvg.appendChild(wallLine);
        }
    }

    let cellTexts = [];
    if (clues) {
        for (let r = 0; r < H; ++r) {
            for (let c = 0; c < W; ++c) {
                const clue = clues[W*r + c];
                if (clue) {
                    const clueText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    clueText.setAttribute('class', 'clue');
                    clueText.setAttribute('x', c + 0.5);
                    clueText.setAttribute('y', r + 0.5);
                    clueText.textContent = String(clue);
                    puzzleSvg.appendChild(clueText);
                    cellTexts.push(clueText);
                } else {
                    const targetRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    targetRect.setAttribute('class', 'target');
                    targetRect.setAttribute('x', c);
                    targetRect.setAttribute('y', r);
                    targetRect.setAttribute('width', 1);
                    targetRect.setAttribute('height', 1);
                    const targetText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    targetText.setAttribute('class', 'target');
                    targetText.setAttribute('x', c + 0.5);
                    targetText.setAttribute('y', r + 0.5);
                    targetRect.onclick = () => selectTarget(targetRect, targetText);
                    cellTexts.push(targetText);
                    puzzleSvg.appendChild(targetRect);
                    puzzleSvg.appendChild(targetText);
                }
            }
        }
    }

    addLines(mazeEdges, 'edge');
    addLines(mazeWalls, 'wall');

    const borderRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
    borderRect.setAttribute('class', 'border');
    borderRect.setAttribute('x', 0);
    borderRect.setAttribute('y', 0);
    borderRect.setAttribute('width', W);
    borderRect.setAttribute('height', H);
    puzzleSvg.appendChild(borderRect);

    let selectedTargetRect = null;
    let selectedTargetText = null;
    function selectTarget(rect, text) {
        if (selectedTargetRect !== null) {
            selectedTargetRect.classList.remove('selected');
        }
        if (selectedTargetRect === rect) {
            selectedTargetRect = null;
            selectedTargetText = null;
        } else {
            rect.classList.add('selected');
            selectedTargetText = text;
            selectedTargetRect = rect;
        }
    }

    window.onkeypress = function(ev) {
        if (selectedTargetText != null) {
            let i = parseInt(ev.key, 10);
            selectedTargetText.textContent = (i >= 1 && i <= 9) ? String(i) : '';
            recalculateErrors();
        }
    };

    function getDigitAt(i) {
        let s = cellTexts[i].textContent;
        return s ? parseInt(s) : 0;
    }

    function isValid(i) {
        let digit = getDigitAt(i);
        if (!digit) return true;
        if (!(candidates[i] & (1 << (digit - 1)))) return false;
        for (let j of neighbours[i]) {
            let otherDigit = getDigitAt(j);
            if (otherDigit == digit) return false;
        }
        return true;
    }

    function recalculateErrors() {
        for (var i = 0; i < cellTexts.length; ++i) {
            if (isValid(i)) {
                cellTexts[i].classList.remove('wrong');
            } else {
                cellTexts[i].classList.add('wrong');
            }
        }
    }
}
